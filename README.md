# <img src="https://user-images.githubusercontent.com/97428216/160321165-bd337416-a703-4f53-a1f7-5d8844ab66a2.png" align=left width=150> 꿈깨
> 온라인 3D 방탈출 게임 서비스 😴

<br />

## 💭 About

> ‘zzz’ 는 꿈을 꾸는 상태를 표현한 단어이자, 게임 프로젝트의 이름입니다
>
> ‘꿈’ 이라는 매체를 이용하여 상상하고 문제를 풀면서 해결하여
> 방탈출을 하는 것이 본 게임을 이어나갈 수 있는 방법입니다
>
> 당신은 꿈 속에서 얼마만큼의 역량을 발휘할 수 있는지 궁금하지 않으신가요?

<br />

## 📅 프로젝트 기간

- 2022.2.25 ~ 2022.4.9
- 1차 배포 : 2022.3.30

<br />

## 📌 바로가기
- Project : https://zzz-escape.netlify.app
- GitHub 메인페이지 : https://github.com/HangHae99Zzz
- 프론트엔드 GitHub Repository : https://github.com/HangHae99Zzz/dream_escape-fe
- 백엔드 GitHub Respository(NodeJS) : https://github.com/HangHae99Zzz/RoomEscape_BE-nodeJS

<br />

## ✨ 주요 기능

- **`홈`**
  방탈출 게임을 위한 방을 만들고, 랭킹조회 및 게임 설명을 확인할 수 있습니다.
- **`대기`**
  현재 대기중인 인원을 체크하고 게임을 시작할 수 있습니다. 링크로 친구를 초대하고, 보이스 채팅도 가능해요!
- **`게임`**
  팀원들과 보이스채팅을 나누며 방에 배치된 3D 물체를 클릭해 주어진 문제를 풀고 탈출할 수 있습니다. 제한시간 안에 방을 탈출해보세요.

<br />

## 🍎 Team Member - `BackEnd`

<!-- | <img src="" width=200>    | <img src="" width=200> | <img src="" width=200> | -->

|                 **김가은**                 |                  **최규원**                   |                  **반원재**                   |
| :----------------------------------------: | :-------------------------------------------: | :-------------------------------------------: |
| [@Kim gaeun](https://github.com/paran22) | [@Choi kyuwon](https://github.com/cooked-developer)  |[@Ban wonjae](https://github.com/wonjaeban)  |

<br />

## 📚 기술스택

<div align=center> 
  <img src="https://img.shields.io/badge/java-007396?style=for-the-badge&logo=java&logoColor=white">
  <img src="https://img.shields.io/badge/springboot-6DB33F?style=for-the-badge&logo=springboot&logoColor=white">
  <img src="https://img.shields.io/badge/gradle-02303A?style=for-the-badge&logo=gradle&logoColor=white">
  <img src="https://img.shields.io/badge/mockito-CB3837?style=for-the-badge&logo=mockito&logoColor=white">
  <img src="https://img.shields.io/badge/junit5-25A162?style=for-the-badge&logo=junit5&logoColor=white">
  <br>
  <img src="https://img.shields.io/badge/webrtc-333333?style=for-the-badge&logo=webrtc&logoColor=white">
  <img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black"> 
  <img src="https://img.shields.io/badge/node.js-339933?style=for-the-badge&logo=Node.js&logoColor=white">
  <img src="https://img.shields.io/badge/express-000000?style=for-the-badge&logo=express&logoColor=white">
  <img src="https://img.shields.io/badge/pm2-2B037A?style=for-the-badge&logo=pm2&logoColor=white">
  <img src="https://img.shields.io/badge/socket.io-010101?style=for-the-badge&logo=socket.io&logoColor=white">
  <br>
  <img src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&logo=mysql&logoColor=white">
  <img src="https://img.shields.io/badge/spring data jpa-F28D1A?style=for-the-badge&logo=springdatajpa&logoColor=white">
  <img src="https://img.shields.io/badge/aws ec2-07C160?style=for-the-badge&logo=amazonaws&logoColor=white">
  <img src="https://img.shields.io/badge/amazon s3-569A31?style=for-the-badge&logo=amazons3&logoColor=white">
  <br>
  <img src="https://img.shields.io/badge/aws codedeploy-9D1620?style=for-the-badge&logo=amazonaws&logoColor=white">
  <img src="https://img.shields.io/badge/aws codepipeline-072240?style=for-the-badge&logo=amazonaws&logoColor=white">
  <img src="https://img.shields.io/badge/nginx-009639?style=for-the-badge&logo=nginx&logoColor=white">
  <img src="https://img.shields.io/badge/github actions-2088FF?style=for-the-badge&logo=github actions&logoColor=white">
</div>

<div align=center><h3>Tools</h1></div>
<div align=center> 
  <img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">
  <img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white">
  <img src="https://img.shields.io/badge/swagger-85EA2D?style=for-the-badge&logo=swagger&logoColor=white">
</div>

<br />


## 🕹 Convention

`Coding Convention` · `Commit Convention`

<details markdown="1">
<summary>Coding Convention</summary>

### 📍 네이밍 Convention

  ✅ 폴더명은 소문자, Class명은 첫 글자 대문자
  <br>
  ✅ Method는 lowerCamelCase을 사용하고, 동사나 전치사로 시작한다. ex) get/set, init, is/has/can, create, find, to, A-By-B …
  <br>
  ✅ JUnit Test Method : Method명_테스트상태_기대행위  ex) isAdult_AgeLessThan18_False
</details>

<details markdown="2">
<summary>Commit Convention</summary>
  
### 📍 Commit Convention
  
  ✅ 유다시티 커밋 메시지 스타일 가이드 : [참고](https://udacity.github.io/git-styleguide/)
  <br>
  ✅ 본문에는 변경한 class 이름과 어떻게, 무엇을, 왜 변경했는지 자세히 적기
  ```
  커밋 타입: 제목
    //띄어쓰기
   본문
    //띄어쓰기
  (꼬리말 타입: #이슈 번호)
  ```
  
  <br />

> 🚨 커밋 타입

```
Docs: 문서 작업
Feat: 새로운 기능 추가
Fix: 버그를 고친 경우
Refactor: 리팩토링
Comment: 주석 추가 및 변경
Rename: 파일 혹은 폴더명 수정, 경로 변경
Remove: 파일 혹은 기능 삭제
Test: 테스트 관련 작업
Resolve conflicts: 충돌 발생 commit에서 사용(본문, 꼬리말 생략)
```
> 🚨 꼬리말 타입

```
Fixes: 이슈 수정중(아직 해결되지 않은 경우)
Resolves: 이슈 해결했을 때
Ref: 참고할 이슈가 있을 때
```
</details>

<br />

## ⚠️ Error

<details markdown="1">
<summary>Error 관리</summary>
<br>
✅ 모든 에러는 Error Code로 관리
<br>
✅ Error Code마다 httpStatus / errorCode / errorMessage 작성
<br>
✅ errorCode는 httpStatus마다 일련번호를 붙인다("httpStatus_number")  ex) "400_3", "404_4"

</details>

<br />

## 🐾 Branch Strategy

<details markdown="1">
<summary>브렌치 관리</summary>
<br>
✅ 개인별 브렌치(gaeun, kyuwon, wonjae)에서 작업 후 테스트 통과 확인한 후에 push → main으로 PR
<br>
✅ 기능 개발을 위해 별도로 테스트하는 경우에도 새로운 브렌치에서 작업 : 이후 반영 시 main으로 PR 후 Close
<br>
✅ nodeJS는 별도의 Repository에서 관리하며, main에서 작업 진행
<br />
</details>


<details markdown="1">
<summary>이슈 관리</summary>
<br>
✅ issue template 사용 : bug, feature
<br>
✅ issue 작성 내용 중 변경사항이 있는 경우에는 해당 글에 comment나 별도 이슈 생성
<br>
✅ 완료된 이슈는 commit Resolves 사용해서 Close
<br>
✅ 관련된 이슈가 많을 경우에는 Milestones를 사용해서 관리

</details>

<br />

## 📺 Detail

<details markdown="1">
<summary>아키텍처</summary>
  <img src="https://user-images.githubusercontent.com/97428216/160459796-c7f708e3-712a-4f33-9578-5c0f46db0acb.png">
</details>

<details markdown="2">
<summary>ERD</summary>
  <img src="https://user-images.githubusercontent.com/97428216/160526555-121176c2-32a6-4968-868c-669ae7234f14.png">

</details>

<details markdown="3">
<summary>API 명세서</summary>
  
> 🚨 API 설계규칙

```
Rest API URI 설계규칙을 따른다.
  1. 후행 /는 URI에 포함하지 않는다.
  2. 계층관계를 나타낼 때 슬래시 구분자를 사용한다. ex) /rooms/{roomId}/quizzes/{quizType}
  3. 긴 path를 표현하는 경우에는 가독성을 높이기 위해 하이픈(-)을 사용한다.
  4. 언더바(_)는 URI에 사용하지 않는다.
  5. URI는 모두 소문자로 작성한다.
  6. 파일확장자는 URI에 포함하지 않는다.
  7. 모든 resource는 복수형을 사용한다.
```
  <img src="https://user-images.githubusercontent.com/97428216/160456913-5247d722-6812-4400-93bf-0e3e0b540764.png">
  <img src="https://user-images.githubusercontent.com/97428216/160457294-af27cb69-7bd4-48d2-ba81-7c119516b9ea.png">
  <img src="https://user-images.githubusercontent.com/97428216/160457359-8365661e-f2a7-47be-a796-60f8af88071d.png">
  <img src="https://user-images.githubusercontent.com/97428216/160457415-5c72324d-3cb8-4ace-b715-b61f4c3f764c.png">
  <img src="https://user-images.githubusercontent.com/97428216/160457473-2c782847-91f2-4ef7-a9ef-584fa7d53c0c.png">
  <img src="https://user-images.githubusercontent.com/97428216/160457548-d2061496-984c-4ef3-bef4-ab313b324951.png">
</details>

<br />

## 🔨 Trouble Shooting

<details markdown="1">
<summary>WebRTC 서버 구축 문제</summary>

### ✅ P2P(signalling server) vs MCU/SFU → 📍 signalling server를 구축하자!
4명까지 보이스 채팅이 가능한 환경을 만들기 위해 어떤 서버를 사용해야 하는가?
<br>

```
📑 오디오만 사용하고, 4명까지만 연결하기 때문에 signalling server로도 client 부담이 크지 않을 거라고 생각했고,
MCU, SFU는 프로젝트 기한 내에 구현하기 어려울 것으로 판단했다.
```
<br>

### ✅ Springboot vs NodeJS → 📍 NodeJS의 Socket.io를 사용하여 signalling server를 구현하자!
다대다 WebRTC를 위한 signalling server를 어떻게 구현할 것인가?
<br>

```
📑 Springboot를 사용하면 하나의 서버만 관리하면 되고, 팀원들 모두가 익숙한 프레임워크를 사용할 수 있다.
그러나 참고자료가 많지 않다.
📑 NodeJS를 사용하면 Socket.io 라이브러리를 사용해서 비교적 쉽게 구현이 가능하나,
서버를 2개 관리해야 되기 때문에 유지관리에 비용이 더 소모되고, 익숙하지 않은 언어와 프레임워크를 사용해야 한다.
📑 그럼에도 NodeJS의 Socket.io를 사용하는 것이 프로젝트의 목표를 달성하기에 더 적합하다고 판단했다.
```
</details>

<details markdown="2">
<summary>유저 disconnect 처리 문제</summary>
  
### ✅ 문제상황

```
📑 유저가 브라우저를 종료하면 socket.io의 disconnect 이벤트가 발생
📑 Client는 방장이 나가면 새로운 방장을 알아야한다(방장만 게임 시작 가능!)
📑 DB에서는 disconnect된 유저 정보를 삭제하고, 방장이 변경된 경우 업데이트 필요
```
  
### 해결방안 1️⃣ nodeJS → Client →← Spring → ⚠️ 에러 발생
  
```
📑 nodeJS에서 disconnect시 event를 통해 disconnect된 유저의 socket.id를 Client로 보냄
📑 Client는 Spring으로 HTTP 통신을 통해 socket.id를 넘겨주고, 방장이 바뀐 경우 return 값을 받음
📑 유저가 1명 남았는데 disconnect가 되면 Client가 없으므로 nodeJS에서 DB로 쿼리를 보냄
  
  
⚠️ Client에서 동시에 여러 번 업데이트/삭제 요청이 발생하여 에러 발생!! → 📍 DB에 한 번만 요청하자!

```

### 해결방안 2️⃣ disconnect와 관련된 모든 DB처리는 nodeJS에서 처리
  
```
📑 disconnect시 DB에 필요한 업데이트/삭제 쿼리를 보내고, 방장이 변경되면 event로 해당 방 Client에게 알려줌
```
</details>

<details markdown="3">
<summary>게임 플레이 중 동시성 제어 문제</summary>
  
### ✅ 문제상황 → 📍 Socket.io의 이벤트를 활용해서 스코어나 찬스 변경 이벤트 발생 시 해당 방에 데이터 변경 사실 알려줌!

```
📑 게임 중 맞춘 문제 수(스코어), 찬스가 변경될 경우 해당 방 Client 모두에게 해당 정보를 업데이트해주어야 함
📑 HTTP 통신에서는 Client 요청 없이 Server가 Response 할 수 없으므로 socket 통신을 이용하면 해결할 수 있음!
📑 퀴즈를 동시에 보고 있을 때도 한 명이 문제를 풀면 더 이상 문제가 풀리지 않도록 socket 이벤트로 해결한 퀴즈타입 전달
```
</details>

<details markdown="4">
<summary>CI/CD 적용</summary>

### ✅ 배포 자동화를 도입한 이유!

```
📑 배포 자동화를 통해 효율적인 협업 및 작업 환경을 구축하기 위함
```

### ✅ 문제상황

```
📑 Front-end와 협업 시 코드 배포를 해야하는 상황이 빈번히 발생
📑 FileZila를 통한 수동 배포와 배포 이후 에러를 발견시 재배포 하는 일이 잦아짐에 따라 배포에 많은 시간이 소요됨
```

### ✅ 해결방안

```
📑 1안) Travis 
📑 2안) Githup Actions
```

### ✅ 의견 조율

```
📑 1. Travis를 사용하기 위해선 서버 설치가 필요
📑 2. Githup Actions는 별다른 설치 및 복잡한 절차 없이 Githup을 통해 사용 가능
📑 3. Githup Actions는 Github Marketplace를 통해 다른 개발자가 작성한 액션을 재사용 할 수 있으므로 시간이 절약
📑 4. 기간이 한정이 되어 있어서 개발 인프라에 많은 시간을 할애할 수 없다
```

### ✅ 의견 결정

```
📑 처음에는 Travis를 사용하는 블로그 자료들이 더 많아서 우선순위로 두었지만 현재 하는 프로젝트의 규모가 크지 않고 시간적 제약(서버 설치)으로 인해 Githup Actions를 사용하기로 결정
📑 또 다른 이유로는 Github의 다양한 기능들을 써보고 싶었는데 지금 이 기회에 써보고 싶다는 생각이 들었다
```
</details>

<details markdown="5">
<summary>테스트 코드 적용</summary>

### ✅ 테스트코드를 도입한 이유!

```
📑 배포 자동화를 도입했기 때문에 검증되지 않은 코드들이 자동으로 배포될 수 있어 차후에 문제 파악 어려움이 존재.  
-> 테스트코드를 통해 사전 검증의 필요성 존재.
📑 테스트 코드를 통해서 코드 작성시에 고려하지 못했던 case에 대한 확인과 개선이 가능.
📑 리팩토링시에 빠르게 코드를 검증 가능.
```

### ✅ 문제상황

```
📑 단위 테스트(QuizServiceTimeTest)에서 ClueRepository와 QuizRepository를 @Mock으로 처리하지 못하는 문제 발생.
📑 통합 테스트에서 DI 방법으로 @RequiredArgsConstructor를 통한 생성자 주입 방식이 적용 안되는 문제 발생.

```

### ✅ 문제 원인

```
📑 단위 테스트시에 실제 Quizservice에 존재하는 quizRepository.save(roomId)과 clueRepository.findAllByRoomId(room.getId())때문.  
@Mock으로 만들려면 when().thenReturn()같은 메서드를 반드시 명시해줘야하는데 테스트시 정확한 RoomId를 알아내는 것이 불가능.  
->when().thenReturn() 메서드 작동 안함.
📑 통합 테스트에서 DI 방법으로 생성자 주입 방식(@RequiredArgsConstructor)안되는 이유는  
difference in autowire handling between Spring and Spring integration with JUnit때문.

```

### ✅ 해결방안

```
📑 단위테스트에서 따라서 @Spy를 통해서 Stubbing 하지 않은 실제 객체들을 @InjectMocks를 통해서 quizService에 주입시키는 방식으로 해결.
->단위 테스트의 목적이 퀴즈 생성 시간 측정에 있었기 때문에 Mock이 아닌 실제 객체들로 주입하는 것이 오히려 더 낫다 판단(실제로 걸리는 시간 측정 가능).
📑 통합테스트에서 DI 방법으로 @Autowired 방식 선택.

```

</details>

<br />

## 🔧 Fight
<details>
  <summary>ban wonjae</summary>
  
  ### 1️⃣ Trouble Shooting에서 유저 disconnect 해결방안 1과 관련된 삽질
  ```
  📑 처음에 node.js는 보이스 채팅만 다루고 나머지 역할은 spring에서 담당하기로 했었음  
  -> 스프링에서 한 방의 인원들이 전부 로딩이 다 되었는지 체크.
  
  📑 클라이언트들이 각자 게임 로딩이 다 완료되면 spring에 request를 보냄  
  ->spring에서는 request가 올때마다 count를 세서 count가 현재 한 방의 인원들의 숫자와 같아지면 게임을 시작.
  
  📑 여기서 로딩중에 누군가가 나가면 무한대기현상이 발생할 수 있다고 생각.  
  왜냐하면 나간 사람은 영원히 spring에 로딩이 다 되었다는 request를 보내지 않기 때문.
  
  📑 구체적으로 당시 노드 socket에서 유저 disconnect가 발생  
  -> 스프링에서 1. 방장이 나간 경우: 새로운 방장 userId response.	2. 일반인이 나간 경우: null response.
  
  📑 spring에서 게임 로딩 체크  
  -> 1. false response 2. 마지막 인원한테는 true response.
  
  📑 문제는 위 두개의 로직이 동시에 발생하는 경우  
  -> 게임 로딩중에 방장이 disconnect가 된다면 최악의 경우 새로운 방장 userId,   
  게임 무한 대기 현상을 방지하기 위해 마지막 인원까지 로딩이 완료되었다는 true값도 보내줘야함.
  
  📑 따라서 disconnect시 responsedto와 게임 로딩체크 responsedto는 같아야함.  
  즉, 누군가가 나간다면 userID만 넘겨주는 것이 아니라 userId와 true, false값을 같이 보내줌,  
  반대로 게임 로딩중에도 true, false뿐만 아니라 userId까지 보내줌.
  
  📑 이런 방식으로 프론트쪽에서 true 또는 false값도 받는게 가능  
  -> 무한대기현상을 해결할 수 있다 생각함.
  
  📑 즉, 상황에 따라 1. 게임로딩 X, 누군가가 나감 -> 1. 방장이 나간경우: {"userId" : "새로운 ID", "check": null}  
  2. 일반인이 나간경우: {"userId": null, "check":   null}
  
  📑 2. 게임로딩 O, 누군가가 나감 -> 1. 방장이 나갔고 나머지 인원 전부 로딩 완료:{"userId": "새로운ID", "check": "true"},  
  2. 방장이 나갔지만 나머지 인원이 전부 로딩 X:  {"userId": "새로운ID", "check":null},  
  3. 일반인이 나갔는데 나머지 전부 로딩: {"userId" : null, "check": "true"},  
  4. 일반인이 나갔는데 나머지 전부 로딩X: {"userId" :   null, "check": "null"}
  
  📑 3. 일반적인 게임 로딩  
  --> 1. {"userId": null, "check": null} ... 2. 제일 마지막 인원 로딩: {"userId": null, "check":"true"}로 응답하는 것으로 해결하고자 함. 
  
  📑 하지만 disconnect가 발생 -> 방 전체 인원들이 Spring으로 request를 보냄  
  -> disconnect 유저를 삭제하고 새로운 방장을 만드는 로직이 여러번 발생하는 문제 존재.
  
  📑 결론적으로 node에서 socket disconnect시에 한번만 처리하는 것으로 방향 바꿈. 
  ```
  
  </details>
